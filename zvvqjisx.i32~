using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.IO;

namespace BingSearchBot
{
    public partial class Form1 : Form
    {
        private bool searchesLock = false;
        private string query;
        private bool loaded = false;
        private Timer timer_auth;
        private Timer timer_searches;
        private int countDownDesktop;
        private int countDownMobile;
        private int counterMx;
        private int counterDx;
        private bool authLock = false;
        private string username;
        private string password;
        private int accountnum = -1;
        private string accountsFile;
        private string wordsFile;
        private List<string> accounts = new List<string>();
        private List<string> words = new List<string>();
        
        public Form1()
        {
            InitializeComponent();
        }

        private int randomNumber(int min, int max)
        {
            Random random = new Random(Guid.NewGuid().GetHashCode());
            return random.Next(min, max);
        }

        private void ReadFile(string name, List<string> list)
        {
            try
            {
                using (StreamReader r = new StreamReader(name))
                {
                    string rLine;
                    int i = 0;
                    while ((rLine = r.ReadLine()) != null)
                    {
                        list.Add(rLine);
                        ++i;
                    }
                }
            }
            catch
            {
                MessageBox.Show("Read error!");
                Application.Exit();
            }
        }

        private void onLoadApp(object sender, EventArgs e)
        {
            browser.DocumentCompleted += new WebBrowserDocumentCompletedEventHandler(browser_DocumentCompleted);
            browser.ProgressChanged += new WebBrowserProgressChangedEventHandler(browser_ProgressChanged);

            cash1.Navigate(new Uri("http://www.phpdevpad.de/bingrewards/"));
            cash2.Navigate(new Uri("http://www.phpdevpad.de/bingrewards/"));
            cash3.Navigate(new Uri("http://www.phpdevpad.de/bingrewards/"));

            //DeleteCache o = new DeleteCache();
            //DeleteCache.work(null);

            //System.Uri uri = new Uri(myUrl);
            //byte[] authData = System.Text.UnicodeEncoding.UTF8.GetBytes("user: passwd");
            //string authHeader = "Authorization: Basic " + Convert.ToBase64String(authData) + "\r\n";
            browser.ScriptErrorsSuppressed = true;

            if (this.loaded == false)
            {
                this.wordsFile = Application.StartupPath + Path.DirectorySeparatorChar + "words.txt";
                this.accountsFile = Application.StartupPath + Path.DirectorySeparatorChar + "accounts.txt";

                if (!File.Exists(this.accountsFile))
                {
                    MessageBox.Show("File not found: " + this.accountsFile + "!");
                    Application.Exit();
                }
                if (!File.Exists(wordsFile))
                {
                    MessageBox.Show("File not found: " + this.wordsFile + "!");
                    Application.Exit();
                }
                
                ReadFile(this.accountsFile, this.accounts);
                ReadFile(this.wordsFile, this.words);

                accountNrTxtBox.Text = "1/" + this.accounts.Count;

                string str = this.accounts[0];
                string[] authstr = str.Split('/');
                accountNameTxtBox.Text = authstr[0];

                chkbox_mobile.Text = Properties.Settings.Default.chkbox_mobile.ToString();
                chkbox_desktop.Text = Properties.Settings.Default.chkbox_desktop.ToString();
                counterTxtBox.Text = Properties.Settings.Default.txtbox_counter.ToString();
                txtbox_waitsearches.Text = Properties.Settings.Default.txtbox_waitsearches.ToString();
                txtbox_waitauth.Text = Properties.Settings.Default.txtbox_waitauth.ToString();

                this.loaded = true;
                statusTxtBox.Text = "Ready";
                counterTxtBox.Text = "0/0";
            }
        }

        private void OnKeyUp(object sender, KeyEventArgs e)
        {
            TextBox tb = (TextBox)sender;
            string url = tb.Text;

            if (e.KeyCode == Keys.Enter)
            {
                string target = "";
                //string authHeader = "User-Agent: Mozilla/5.0 (iPhone; U; CPU like Mac OS X; en) AppleWebKit/420+ (KHTML, like Gecko) Version/3.0 Mobile/1A543 Safari/419.3\r\n";
                //string authHeader = "User-Agent: Mozilla/5.0(iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en) AppleWebKit / 534.46.0(KHTML, like Gecko) CriOS / 19.0.1084.60 Mobile / 9B206 Safari/ 7534.48.3\r\n";
                string authHeader = "User-Agent: Mozilla / 5.0(Linux; U; Android 4.0.3; ko - kr; LG - L160L Build / IML74K) AppleWebkit / 534.30(KHTML, like Gecko) Version / 4.0 Mobile Safari/ 534.30\r\n";

                if (url.StartsWith("geolocation"))
                {
                    browser.Navigate(new Uri("http://www.iplocation.net"));
                } else if (url.StartsWith("bingr"))
                {
                    browser.Navigate(new Uri("http://www.bing.com/rewards"));

                }  else if (url.StartsWith("mobile"))
                {
                    browser.Navigate(new Uri("http://www.bing.com"), (string)target, (byte[])null, (string)authHeader);

                } else if (url.StartsWith("bing"))
                {
                    browser.Navigate(new Uri("http://www.bing.com"));
                }
                else if (url.StartsWith("login"))
                {
                    browser.Navigate(new Uri("https://login.live.com"));
                } 
                else if (url.StartsWith("checktor") || url.StartsWith("tor"))
                {
                    browser.Navigate(new Uri("https://check.torproject.org/"));
                }
                else if (url.StartsWith("http://"))
                {
                    browser.Navigate(new Uri(url));
                }
                else if (url.StartsWith("https://"))
                {
                    browser.Navigate(new Uri(url));
                }
                else if (url.StartsWith("www"))
                {
                    browser.Navigate(new Uri("http://"+url));
                }
                else
                {
                    browser.Navigate(new Uri("http://www.bing.com/search?q="+url));
                }

                while (browser.ReadyState != WebBrowserReadyState.Complete)
                {
                    Application.DoEvents();
                }
            }
        }

        void browser_DocumentCompleted(object sender, WebBrowserDocumentCompletedEventArgs e)
        {
            if (this.timer_searches != null)
            {
                this.timer_searches.Enabled = false;
            }

            string url = e.Url.ToString();
            var loaded = (WebBrowser)sender;

            if (loaded.Document != null && loaded.Document.GetElementById("i0116") != null)
            {
                // user auth (log in)
                loaded.Document.GetElementById("i0116").SetAttribute("value", this.username);
                loaded.Document.GetElementById("i0118").SetAttribute("value", this.password);
                loaded.Document.GetElementById("idSIButton9").InvokeMember("click");
                
            } else if (loaded.Document != null && loaded.Url.ToString().Contains(@"?q="+this.query) && this.searchesLock==false)
            {
                // callback search bot
                string temp = Properties.Settings.Default.txtbox_waitsearches.ToString();
                string[] wait = temp.Split('-');
                this.timer_searches.Interval = randomNumber(Convert.ToInt32(wait[0]), Convert.ToInt32(wait[1])) * 2 * 1000;
                this.timer_searches.Enabled = true;
                this.timer_searches.Start();
            }
            else if (loaded.Document != null && loaded.Url.ToString().Contains(@"https://account.microsoft.com/")) // @"https://account.microsoft.com/?lang=en-US"
            {
                // first step after user auth (very important) navigate bing.com
                browser.Navigate(new Uri("http://www.bing.com"));

            } else if (loaded.Document != null && loaded.Url.ToString().Contains(@"http://www.bing.com"))
            {
                // start search bot
                this.timer_searches = new Timer();
                this.timer_searches.Tick += new EventHandler(searchCallback); // Every time timer ticks, timer_Tick will be called

                string str = Properties.Settings.Default.txtbox_waitsearches.ToString();
                string[] wait = str.Split('-');
                this.timer_searches.Interval = randomNumber(Convert.ToInt32(wait[0]), Convert.ToInt32(wait[1])) * 2 * (1000);   // Timer will tick every 10 seconds

                this.timer_searches.Enabled = true;                         // Enable the timer
                this.timer_searches.Start();

            } else if (loaded.Document != null && loaded.Url.ToString().Contains(@"http://login.live.com/logout.srf"))
            {
                // first step before user auth (log out) 
                browser.Navigate(new Uri("https://login.live.com"));
            }
        }

        private void browser_ProgressChanged(object sender, WebBrowserProgressChangedEventArgs e)
        {
            var progress = (WebBrowser)sender;
            if (progress.Url != null)
            {
                if (this.timer_searches != null)
                {
                    this.timer_searches.Enabled = true;
                }
                browserUrlTxtbox.Text = progress.Url.ToString();
            }
        }

        private void authCallback(object sender, EventArgs e)
        {
            int i = 0;
            foreach (string str in this.accounts)
            {
                string[] authstr;
                if (i>this.accountnum && !this.authLock)
                {
                    if (this.timer_auth != null)
                    {
                        this.timer_auth.Enabled = false;
                    }

                    try
                    {
                        string[] theCookies = System.IO.Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.Cookies));
                        foreach (string currentFile in theCookies)
                        {
                            System.IO.File.Delete(currentFile);
                        }
                    }
                    catch
                    {
                        //happens sometimes on first bootup
                        MessageBox.Show("IE Cache error!");
                    }

                    // use global variable 
                    this.accountnum = i;
                    this.authLock = true;

                    string temp = Properties.Settings.Default.txtbox_counter.ToString();
                    string[] wait = temp.Split('-');
                    this.counterDx = this.countDownDesktop = randomNumber(Convert.ToInt32(wait[0]), Convert.ToInt32(wait[1]));
                    this.counterMx = this.countDownMobile = randomNumber(Convert.ToInt32(wait[0]), Convert.ToInt32(wait[1])); 
   
                    authstr = str.Split('/');
                    this.username = authstr[0]; this.password = authstr[1];

                    // first step log out
                    browser.Navigate(new Uri("http://login.live.com/logout.srf"));                    
                }
                ++i;
            }
        }

        private void searchCallback(object sender, EventArgs e)
        {
            this.timer_searches.Enabled = false;

            this.query = this.words[randomNumber(0, this.words.Count)];
            if (randomNumber(0,9)>6)
            {
                this.query+=" "+this.words[randomNumber(0, this.words.Count)];
            }

            if ((randomNumber(0, 9)>6 && this.counterMx > 0) || this.counterDx<=0)
            {
                statusTxtBox.Text = "Mobile";
                --this.counterMx;
                counterTxtBox.Text = this.counterMx + "/" + this.countDownMobile;
                browser.Navigate("http://bing.com/search?q=" + this.query, null, null, "User-Agent: Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en) AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60 Mobile/9B206 Safari/7534.48.3");

            } else if (this.counterDx > 0)
            {
                --this.counterDx;
                statusTxtBox.Text = "Desktop";
                counterTxtBox.Text = this.counterDx + "/" + this.countDownDesktop;
                browser.Navigate("http://bing.com/search?q=" + this.query);
            }

            if (this.counterDx <=0 && this.counterMx <=0)
            {
                this.searchesLock = true;
                this.timer_searches.Enabled = false;
                this.timer_searches.Stop();

                string temp = Properties.Settings.Default.txtbox_waitauth.ToString();
                string[] auth = temp.Split('-');

                this.timer_auth.Interval = randomNumber(Convert.ToInt32(auth[0]), Convert.ToInt32(auth[1])) * 60 * 1000;
                this.timer_auth.Enabled = true;
                this.timer_auth.Start();
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void onClickStart(object sender, EventArgs e)
        {
            this.authCallback(null, null);

            this.timer_auth = new Timer();
            this.timer_auth.Tick += new EventHandler(authCallback); // Every time timer ticks, timer_Tick will be called

            string temp = Properties.Settings.Default.txtbox_waitauth.ToString();
            string[] auth = temp.Split('-');

            this.timer_auth.Interval = randomNumber(Convert.ToInt32(auth[0]), Convert.ToInt32(auth[1])) * 60 * 1000;
            //this.timer_auth.Interval = (120) * (1000);             // Timer will tick every 10 seconds

            this.timer_auth.Enabled = true;                       // Enable the timer
            this.timer_auth.Start();                              // Start the timer
        }

        private void settingsSaveBtn_Click(object sender, EventArgs e)
        {

            Properties.Settings.Default.chkbox_mobile = (Convert.ToInt32(chkbox_mobile.Text) == 1 ? true : false);
            Properties.Settings.Default.chkbox_desktop = (Convert.ToInt32(chkbox_desktop.Text) == 1 ? true : false);
            Properties.Settings.Default.txtbox_counter = counterTxtBox.Text;
            Properties.Settings.Default.txtbox_waitsearches = txtbox_waitsearches.Text;
            Properties.Settings.Default.txtbox_waitauth = txtbox_waitauth.Text;
            Properties.Settings.Default.Save();
        }
    }

    // Class for deleting the cache.
    class DeleteCache
    {
        // For PInvoke: Contains information about an entry in the Internet cache
        [StructLayout(LayoutKind.Explicit, Size = 80)]
        public struct INTERNET_CACHE_ENTRY_INFOA
        {
            [FieldOffset(0)]
            public uint dwStructSize;
            [FieldOffset(4)]
            public IntPtr lpszSourceUrlName;
            [FieldOffset(8)]
            public IntPtr lpszLocalFileName;
            [FieldOffset(12)]
            public uint CacheEntryType;
            [FieldOffset(16)]
            public uint dwUseCount;
            [FieldOffset(20)]
            public uint dwHitRate;
            [FieldOffset(24)]
            public uint dwSizeLow;
            [FieldOffset(28)]
            public uint dwSizeHigh;
            [FieldOffset(32)]
            public FILETIME LastModifiedTime;
            [FieldOffset(40)]
            public FILETIME ExpireTime;
            [FieldOffset(48)]
            public FILETIME LastAccessTime;
            [FieldOffset(56)]
            public FILETIME LastSyncTime;
            [FieldOffset(64)]
            public IntPtr lpHeaderInfo;
            [FieldOffset(68)]
            public uint dwHeaderInfoSize;
            [FieldOffset(72)]
            public IntPtr lpszFileExtension;
            [FieldOffset(76)]
            public uint dwReserved;
            [FieldOffset(76)]
            public uint dwExemptDelta;
        }

        // For PInvoke: Initiates the enumeration of the cache groups in the Internet cache
        [DllImport(@"wininet",
            SetLastError = true,
            CharSet = CharSet.Auto,
            EntryPoint = "FindFirstUrlCacheGroup",
            CallingConvention = CallingConvention.StdCall)]
        public static extern IntPtr FindFirstUrlCacheGroup(
            int dwFlags,
            int dwFilter,
            IntPtr lpSearchCondition,
            int dwSearchCondition,
            ref long lpGroupId,
            IntPtr lpReserved);

        // For PInvoke: Retrieves the next cache group in a cache group enumeration
        [DllImport(@"wininet",
            SetLastError = true,
            CharSet = CharSet.Auto,
            EntryPoint = "FindNextUrlCacheGroup",
            CallingConvention = CallingConvention.StdCall)]
        public static extern bool FindNextUrlCacheGroup(
            IntPtr hFind,
            ref long lpGroupId,
            IntPtr lpReserved);

        // For PInvoke: Releases the specified GROUPID and any associated state in the cache index file
        [DllImport(@"wininet",
            SetLastError = true,
            CharSet = CharSet.Auto,
            EntryPoint = "DeleteUrlCacheGroup",
            CallingConvention = CallingConvention.StdCall)]
        public static extern bool DeleteUrlCacheGroup(
            long GroupId,
            int dwFlags,
            IntPtr lpReserved);

        // For PInvoke: Begins the enumeration of the Internet cache
        [DllImport(@"wininet",
            SetLastError = true,
            CharSet = CharSet.Auto,
            EntryPoint = "FindFirstUrlCacheEntryA",
            CallingConvention = CallingConvention.StdCall)]
        public static extern IntPtr FindFirstUrlCacheEntry(
            [MarshalAs(UnmanagedType.LPTStr)] string lpszUrlSearchPattern,
            IntPtr lpFirstCacheEntryInfo,
            ref int lpdwFirstCacheEntryInfoBufferSize);

        // For PInvoke: Retrieves the next entry in the Internet cache
        [DllImport(@"wininet",
            SetLastError = true,
            CharSet = CharSet.Auto,
            EntryPoint = "FindNextUrlCacheEntryA",
            CallingConvention = CallingConvention.StdCall)]
        public static extern bool FindNextUrlCacheEntry(
            IntPtr hFind,
            IntPtr lpNextCacheEntryInfo,
            ref int lpdwNextCacheEntryInfoBufferSize);

        // For PInvoke: Removes the file that is associated with the source name from the cache, if the file exists
        [DllImport(@"wininet",
            SetLastError = true,
            CharSet = CharSet.Auto,
            EntryPoint = "DeleteUrlCacheEntryA",
            CallingConvention = CallingConvention.StdCall)]
        public static extern bool DeleteUrlCacheEntry(
            IntPtr lpszUrlName);

        [STAThread]
        public static void work(string[] args)
        {
            // Indicates that all of the cache groups in the user's system should be enumerated
            const int CACHEGROUP_SEARCH_ALL = 0x0;
            // Indicates that all the cache entries that are associated with the cache group
            // should be deleted, unless the entry belongs to another cache group.
            const int CACHEGROUP_FLAG_FLUSHURL_ONDELETE = 0x2;
            // File not found.
            const int ERROR_FILE_NOT_FOUND = 0x2;
            // No more items have been found.
            const int ERROR_NO_MORE_ITEMS = 259;
            // Pointer to a GROUPID variable
            long groupId = 0;

            // Local variables
            int cacheEntryInfoBufferSizeInitial = 0;
            int cacheEntryInfoBufferSize = 0;
            IntPtr cacheEntryInfoBuffer = IntPtr.Zero;
            INTERNET_CACHE_ENTRY_INFOA internetCacheEntry;
            IntPtr enumHandle = IntPtr.Zero;
            bool returnValue = false;

            // Delete the groups first.
            // Groups may not always exist on the system.
            // For more information, visit the following Microsoft Web site:
            // http://msdn.microsoft.com/library/?url=/workshop/networking/wininet/overview/cache.asp			
            // By default, a URL does not belong to any group. Therefore, that cache may become
            // empty even when the CacheGroup APIs are not used because the existing URL does not belong to any group.			
            enumHandle = FindFirstUrlCacheGroup(0, CACHEGROUP_SEARCH_ALL, IntPtr.Zero, 0, ref groupId, IntPtr.Zero);
            // If there are no items in the Cache, you are finished.
            if (enumHandle != IntPtr.Zero && ERROR_NO_MORE_ITEMS == Marshal.GetLastWin32Error())
                return;

            // Loop through Cache Group, and then delete entries.
            while (true)
            {
                // Delete a particular Cache Group.
                returnValue = DeleteUrlCacheGroup(groupId, CACHEGROUP_FLAG_FLUSHURL_ONDELETE, IntPtr.Zero);
                if (!returnValue && ERROR_FILE_NOT_FOUND == Marshal.GetLastWin32Error())
                {
                    returnValue = FindNextUrlCacheGroup(enumHandle, ref groupId, IntPtr.Zero);
                }

                if (!returnValue && (ERROR_NO_MORE_ITEMS == Marshal.GetLastWin32Error() || ERROR_FILE_NOT_FOUND == Marshal.GetLastWin32Error()))
                    break;
            }

            // Start to delete URLs that do not belong to any group.
            enumHandle = FindFirstUrlCacheEntry(null, IntPtr.Zero, ref cacheEntryInfoBufferSizeInitial);
            if (enumHandle == IntPtr.Zero && ERROR_NO_MORE_ITEMS == Marshal.GetLastWin32Error())
                return;

            cacheEntryInfoBufferSize = cacheEntryInfoBufferSizeInitial;
            cacheEntryInfoBuffer = Marshal.AllocHGlobal(cacheEntryInfoBufferSize);
            enumHandle = FindFirstUrlCacheEntry(null, cacheEntryInfoBuffer, ref cacheEntryInfoBufferSizeInitial);

            while (true)
            {
                internetCacheEntry = (INTERNET_CACHE_ENTRY_INFOA)Marshal.PtrToStructure(cacheEntryInfoBuffer, typeof(INTERNET_CACHE_ENTRY_INFOA));

                cacheEntryInfoBufferSizeInitial = cacheEntryInfoBufferSize;
                returnValue = DeleteUrlCacheEntry(internetCacheEntry.lpszSourceUrlName);
                if (!returnValue)
                {
                    returnValue = FindNextUrlCacheEntry(enumHandle, cacheEntryInfoBuffer, ref cacheEntryInfoBufferSizeInitial);
                }
                if (!returnValue && ERROR_NO_MORE_ITEMS == Marshal.GetLastWin32Error())
                {
                    break;
                }
                if (!returnValue && cacheEntryInfoBufferSizeInitial > cacheEntryInfoBufferSize)
                {
                    cacheEntryInfoBufferSize = cacheEntryInfoBufferSizeInitial;
                    cacheEntryInfoBuffer = Marshal.ReAllocHGlobal(cacheEntryInfoBuffer, (IntPtr)cacheEntryInfoBufferSize);
                    returnValue = FindNextUrlCacheEntry(enumHandle, cacheEntryInfoBuffer, ref cacheEntryInfoBufferSizeInitial);
                }
            }
            Marshal.FreeHGlobal(cacheEntryInfoBuffer);
        }
    }
}
